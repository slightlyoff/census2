<!--
Copyright (C) 2007 James Ward
http://www.jamesward.org


This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Modified Nov 2008, Alex Russell
-->
<html>
<head>
	<title>Census - RIA Data Loading Benchmarks</title>
	<link rel="stylesheet" href="resources/main.css" type="text/css">
	<link rel="stylesheet" href="dojo/dojo/resources/dojo.css" type="text/css">
	<link rel="stylesheet" href="dojo/dijit/themes/dijit.css" type="text/css">
	<link rel="stylesheet" href="dojo/dijit/themes/tundra/tundra.css" type="text/css">
	<link rel="stylesheet" href="resources/census.css" type="text/css">
	<style type="text/css">
	</style>
	<!-- grab the core of Dojo -->
	<script src="dojo/dojo/dojo.js" language="javascript"
		djConfig="parseOnLoad: true"></script>
	<!--
		the census.js layer file includes nearly all of the dependencies for
		this page, making most of the following require() statements simple
		formalities (and no-ops)
	-->
	<script src="dojo/dojo/census.js" language="javascript"></script>
	<script type="text/javascript">
		// dojo dependencies
		dojo.require("dijit.dijit");
		dojo.require("dijit.layout.ContentPane");
		dojo.require("dijit.layout.BorderContainer");
		dojo.require("dijit.layout.TabContainer");
		dojo.require("dijit.form.CheckBox");
		dojo.require("dijit.form.Button");
		dojo.require("dojox.widget.Iterator");
		dojo.require("dojox.charting.Chart2D");
		dojo.require("dojox.charting.widget.Legend");
		dojo.require("dojox.lang.functional.sequence");
		dojo.require("dojox.charting.Theme");

		// TODO:
		//		* revise census layer with added dependencies
		//		* add a 'raw data' view of test results (in a grid?)
		//		* a progress meter of some sort to give visual feedback of individual tests
		//		* finish the "guided" pane
		//		* provide a UI to tweak the # of times a given test is run
		//		* theme buttons and drop-downs

		// color groups:
		colorGroups = [
			[ "#e28741", "#c6691c" ],
			[ "#467299", "#2a547a" ],
			[ "#f6c54c", "#d8a62d" ],
			[ "#ff3f20", "#c92719" ],
			[ "#44aa77", "#339966", "#246d49" ],
			[ "#dd0000", "#990000", "#6d0000" ] // memory
		];


		// define a new theme based on our color group
		DarkHorse = new dojox.charting.Theme({
			chart: { fill: "transparent" },
			plotarea: { fill: "#151515" },
			axis: {
				stroke:	{ //	the axis itself
					color: "#111111", width: 1
				},
				fontColor: "#a9a9a9",
				font: "normal normal normal 11px HelveticaNeue-Light",
				fill: "#a9a9a9"
			},
			colors: dojo.map(colorGroups, "return item[0];")
		});

		sum = function(list){
			var s = 0;
			dojo.forEach(list, function(i){ s += i; });
			return s;
		}
		mean = function(list, property){
			if(!list.length){ return 0; }
			return (sum(dojo.map(list, function(i){ return i[property]||0; }))/list.length); 
		}

		// a quick class to describe test items. Items in the global "testList"
		// are instances of this class
		dojo.declare("Test", null, {
			constructor: function(item){
				this.averages = dojo.delegate(Test.prototype.averages);
				if(item){
					dojo.mixin(this, item);
				}
				this.testInit();
			},
			_results: [],
			testInit: function(){
				this._results = [];
			},
			_currentlyRunning: null,
			report: function(properties){
				this._killFlightTimer();
				// add our results to the list and re-generate the averages
				this._results.push(properties);
				if(this._currentlyRunning){
					this._currentlyRunning.callback(properties);
				}
				var dataItems;
				if(this._results.length > 2){
					// calculate the current running averages
					this._results.sort(function(a, b){
						a.total - b.total;
					});
					dataItems = this._results.slice(1, -1);
					for(var x in this.averages){
						this.averages[x] = mean(dataItems, x);
					};
				}
			},

			testCount: 5, // how many times to run a given test
			timeout: 30000, // thirty seconds is the default timeout for each test run

			_inFlightTests: [],
			_flightTimer: null,
			_doTestRun: function(){
				dojo.byId("testContent").src = this.file;
			},
			_killFlightTimer: function(){
				if(this._inFlightTimer){
					clearTimeout(this._inFlightTimer);
					this._inFlightTimer = null;
				}
			},
			_killRunning: function(){
				if(this._currentlyRunning){
					if(this._currentlyRunning.fired < 0){
						this._currentlyRunning.errback(false);
					}
				}
			},
			addTests: function(list){
				dojo.forEach((new Array(this.testCount)), function(i, idx){
					// the list will always have at least a head Deferred
					var last = list[list.length-1];
					var def = new dojo.Deferred();
					var runner = dojo.hitch(this, function(){
						this._killFlightTimer();
						this._killRunning();
						this._currentlyRunning = def;
						this._doTestRun();
					});
					last.addBoth(runner);
					list.push(def);
				}, this);
			},
			name: "",
			file: "",
			desc: "",

			// test averages
			averages: {
				serverExecTime: 0,
				transferTime: 0,
				parseTime: 0,
				renderTime: 0,
				bandwidth: 0,
				total: 0
			}
		});

		runSelected = function(all){
			var items = all ? tests.children :
				dojo.filter(tests.children, "return item.checkbox.checked;");
			if(!testList){ return; } // FIXME: report to user!
			runTests(dojo.filter(testList, function(t){
				return dojo.some(items, function(i){ return i.file == t.file; });
			}));
		}

		runTests = function(tests){
			var first = new dojo.Deferred();
			var tl = [ first ];
			dojo.forEach(tests, function(t){
				t.testInit();
				t.addTests(tl);
			});
			first.callback(true);
		}

		reportResults = function(file, properties){
			if(!testList){ return; }
			if(!properties){ return; }
			var tl = dojo.filter(testList, function(i){ return i.file == file; });
			if(!tl.length){
				console.debug("no matching test registered for:", file);
			}
			dojo.forEach(tl, function(t){ t.report(properties); });
			updateCharts();
		}

		testList = null;

		setTestList = function(list){
			try{
			list = dojo.map(list, "return new Test(item);");
			tests.onDataAvailable(list);

			// upgrade the items in the list to hold slots for their data:
			testList = list.reverse();

			/*
			// for old browsers
			dojo.query(".censusTable tr").
				onmouseenter(function(e){
					console.debug(this);
					dojo.addClass(this, "censusTrHover");
				}).
				onmouseleave(function(e){
					console.debug(this);
					dojo.removeClass(this, "censusTrHover");
				});
			*/

			// visual axis configurationsshared between the bandwidth and
			// timing charts

			var xAxisConfig = {
				majorLabels: true, 
				minorLabels: true, 
				includeZero: true, 
				minorTicks: false, 
				microTicks: false, 
				htmlLabels: true,
				fixUpper: "major", fixLower: "major", 
				majorTick: { length: 3 }
			};

			var yAxisConfig = {
				vertical: true,  // this is the vertical axis
				fixLower: "none", // don't make space at the bottom
				fixUpper: "none", // ...or the top of the graph
				natural: true,
				majorTickStep: 1, // show all the labels
				htmlLabels: true, // and use HTML to do it so we get the right fonts and such
				includeZero: false, // don't include the 0th item 
				majorTick: { length: 0 }, // and squelch those unsightly tick marks
				labels: dojo.map(testList, "return { value: index+1, text: item.name };")
			};

			var chartHeight = 225;

			// create and configure the initial charts
			perfChart = new dojox.charting.Chart2D("perfChart").
				setTheme(DarkHorse).
				addAxis("x", xAxisConfig).
				addAxis("y", yAxisConfig).
				addPlot("default", { 
					type: "StackedBars", 
					minBarSize: 3,
					maxBarSize: 3,
					gap: 3
				}).
				addSeries(
					"Server Exec Time", 
					dojo.map(testList, "return item.averages.serverExecTime;"),
					{
						stroke: { width: 0 } // , 
						/*
						fill: {
							type: "linear",
							x1: 0, y1: 0,
							x2: 0, y2: chartHeight,
							colors: [
								{ color: "#e28741", offset: 0 },
								{ color: "#c6691c", offset: 1 }
							]
						}
						*/
					}
				).
				addSeries(
					"Transfer Time", 
					dojo.map(testList, "return item.averages.transferTime;"),
					{ stroke: { width: 0 } }
				).
				addSeries(
					"Parse Time", 
					dojo.map(testList, "return item.averages.parseTime;"),
					{ stroke: { width: 0 } }
				).
				addSeries(
					"Render Time", 
					dojo.map(testList, "return item.averages.renderTime;"),
					{ stroke: { width: 0 } }
				).
			render();

			/*
			// hack for gradients
			var run = chart.runs[name];
			var group = run.group;
			dojo.forEach(group.children, function(rect){
				var bbox = rect.getBoundingBox();
				// set your gradient using absolute coordinates
				rect.setFill(yourFancyFill);
			});
			*/
			perfLegend = new dojox.charting.widget.Legend({ chart: perfChart }, "perfLegend");

			bandChart = new dojox.charting.Chart2D("bandChart").
				setTheme(DarkHorse).
				addAxis("x", xAxisConfig).
				addAxis("y", yAxisConfig).
					addPlot("default", { 
					type: "Bars", 
					minBarSize: 3,
					maxBarSize: 3,
					gap: 3
				}).
				addSeries("Bandwidth", 
					dojo.map(testList, "return item.averages.bandwidth;"),
					{ stroke: { width: 0 } }
				).
			render();

			bandLegend = new dojox.charting.widget.Legend({ chart: bandChart }, "bandLegend");

			totalTimeChart = new dojox.charting.Chart2D("totalTimeChart").
				setTheme(DarkHorse).
				addAxis("x", xAxisConfig).
				addAxis("y", yAxisConfig).
					addPlot("default", { 
					type: "Bars", 
					minBarSize: 3,
					maxBarSize: 3,
					gap: 3
				}).
				addSeries("Total Test Time", 
					dojo.map(testList, "return item.averages.total;"),
					{ stroke: { width: 0 } }
				).
			render();

			totalTimeLegend = new dojox.charting.widget.Legend({ chart: totalTimeChart }, "totalTimeLegend");
			}catch(e){ console.debug(e); }
		}

		updateCharts = function(){
			perfChart.
				updateSeries("Server Exec Time", 
					dojo.map(testList, "return item.averages.serverExecTime;")).
				updateSeries("Transfer Time", 
					dojo.map(testList, "return item.averages.transferTime;")).
				updateSeries("Parse Time", 
					dojo.map(testList, "return item.averages.parseTime;")).
				updateSeries("Render Time", 
					dojo.map(testList, "return item.averages.renderTime;")).
			render();
			perfLegend.refresh();

			bandChart.
				updateSeries("Bandwidth", 
					dojo.map(testList, "return item.averages.bandwidth;")).
			render();
			bandLegend.refresh();

			totalTimeChart.
				updateSeries("Total Test Time", 
					dojo.map(testList, "return item.averages.total;")).
			render();
			totalTimeLegend.refresh();
		}

		dojo.addOnLoad(function(){

			// get the list of tests and populate things accordingly
			dojo.xhrGet({
				url: "tests.json",
				handleAs: "json",
				load: setTestList
			});
		});
	</script>
</head>
<body class="tundra census">
	<!-- we use a BorderContainer for the main page layout -->
	<div dojoType="dijit.layout.BorderContainer" id="main">
		<!-- 
			tabs for the left-hand panel. We use CSS to remove the "tab"
			appearance but since we're using the Dojo tab class, we'll get to
			keep all of the accessibility behavior and keyboard handling
		-->
		<div dojoType="dijit.layout.TabContainer" 
			tabPosition="top" splitter="true" region="left"
			style="width: 270px;" class="mainPane leftContainer">

			<!-- the "Guide Me" UI -->
			<div dojoType="dijit.layout.ContentPane" title="Guide Me">
				<button dojoType="dijit.form.Button" onClick="runSelected(true);"
					style="width: 100%;">
					Run 'Em All
				</button>
			</div>

			<!-- the "Navigator" UI -->
			<div dojoType="dijit.layout.ContentPane" title="Navigator" class="tests">
				<button dojoType="dijit.form.Button" onClick="runSelected();">
					Run Selected Tests
				</button>
				<table class="censusTable" cellspacing="0">
					<tbody>
						<tr dojoType="dojox.widget.Iterator" jsId="tests" id="tests">
							<td class="checkbox" style="width: 20px;">
								<div dojoType="dijit.form.CheckBox"
									dojoAttachPoint="checkbox">${file}</div>
							</td>
							<td class="name" style="width: 100px;">${name}</td>
							<td class="desc">${desc}</td>
						</tr>
					</tbody>
				</table>
			</div>

			<!-- the "Help" UI, loaded externally on demand -->
			<div dojoType="dijit.layout.ContentPane" 
				title="Help" id="help" href="help.html">
			</div>
		</div>

		<!-- a tab container for the charting and test output UI -->
		<div dojoType="dijit.layout.TabContainer" attachParent="true" tabPosition="bottom"
			region="center" class="mainPane">

			<!-- charts -->
			<div dojoType="dijit.layout.ContentPane" title="Charts" 
				style="overflow-x: hidden; overflow-y: auto;">

				<div id="perfLegend" style="width: 100%; height: 50px;"></div>
				<div id="perfChart" style="width: 100%; height: 225px;"></div>
				<div id="bandLegend" style="width: 100%; height: 50px;"></div>
				<div id="bandChart" style="width: 100%; height: 225px;"></div>
				<div id="totalTimeLegend" style="width: 100%; height: 50px;"></div>
				<div id="totalTimeChart" style="width: 100%; height: 225px;"></div>
				<script type="dojo/connect" event="resize" args="size">
					// resize the charts if our outer size changes
					if(this._resizeTimer){
						clearTimeout(this._resizeTimer);
					}
					if(perfChart && perfChart.resize){
						// keep the height but change the width
						this._resizeTimer = setTimeout(function(){
							perfChart.resize(size.w-10, 225);
							bandChart.resize(size.w-10, 225);
							totalTimeChart.resize(size.w-10, 225);
						}, 50);
					}
				</script>
			</div>

			<!-- test output (if any) -->
			<div dojoType="dijit.layout.ContentPane" 
				title="Output" jsId="output"
				style="padding: 0px; margin; 0px; border: none;">
				<iframe id="testContent" src="blank.html"
					style="padding: 0px; margin; 0px; border: none;"></iframe>
				<script type="dojo/connect" event="resize" args="size">
					// make sure our iframe resizes to fit whatever size we've been given
					dojo.style("testContent", {
						width: size.w,
						height: size.h
					});
				</script>
			</div>

			<div dojoType="dijit.layout.ContentPane" 
				title="Methodology" href="methodology.html"
				style="padding: 0px; margin; 0px; border: none;">
			</div>
		</div>

	</div>
</body>
</html>
